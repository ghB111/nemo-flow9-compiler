import lingo/pegcode/driver;
import runtime;
import string;

Program(varDecls: VarDeclSection, statement: Statement);
VarDeclSection(decls: [VarDecl]);
VarDecl(varName: string, varType: string);
Statement ::= Assignement, Sequence, Test, NonDetChoice, NonDetIteration;
    Assignement(varName: string, value: Expr);
    Sequence(sequence: [Statement]);
    Test(pred: Expr);
    NonDetChoice(choice: [Statement]);
    NonDetIteration(iteratee: Statement);



BinaryOp ::= Sum, Minus, Mult, Div, MoreThan, MoreThanEqual, LessThan, LessThanEqual, Equal;
    Sum();
    Minus();
    Mult();
    Div();
    MoreThan();
    MoreThanEqual();
    LessThan();
    LessThanEqual();
    Equal();
FuncArgs(args: [Expr]);
Expr ::= Int, Id, FunctionCall, ArrayConst;
    ArrayConst(elems: [Expr]);
    ArithExpr(lhs: Expr, rhs: Expr, op: BinaryOp);
    Int(val: int);
    FunctionCall(funcName: string, args: FuncArgs);
    Id(name: string);


stringToAst(str : string) -> Program {
    parsic(
        lingoGrammar(), 
        str,
        defaultPegActions
        // SemanticActions(setTree(defaultPegActions.t, "createProgram", \s -> ArInt(s[0])))
    );
}

// Singleton keeping the compiled grammar
lingoGrammarOp : ref Maybe<[PegOp]> = ref None();

lingoGrammar() {
	// Prepare the grammar in the given file using flow syntax for inlining a string from a file
	// but be sure to only do this once
	onlyOnce(lingoGrammarOp, \ -> {
		compilePegGrammar("#include ./nemo.lingo");
	});
}


VmText(commands: [VmCommand]);
VmCommand ::= AssignementCommand, BranchCommand;
    AssignementCommand(label: int, lhsName: string, newVal: Expr, gotos: [int]);
    BranchCommand(label: int, cond: Expr, thens: [int], elses: [int]);

maxLabel(text: VmText) -> int {
    fold(text.commands, -1, \maxLabel, nextInstruction ->  {
            switch(nextInstruction) {
                AssignementCommand(label, lhsName, newVal, gotos): {
                    if (label > maxLabel) label else maxLabel
                }
                BranchCommand(label, cond, thens, elses): {
                    if (label > maxLabel) label else maxLabel
                }
            }
        }
    )
}

// shiftLabels(text: VmText, delta: int) -> VmText {
//     // todo
// }

// substituteLabels(text: VmText, oldLabel: int, newLabel: int) -> VmText {

// }

compile(ast: Program) -> string {
    // notypechecking for now
    "todo"
}

main() {
    programText = getFileContent("./program.nemo");
    ast : Program = stringToAst(programText);
    println("AST:");
    println(ast);

    println("compiled:");
    println(compile(ast));
}

// flowcpp --no-jit ../../lib/lingo/pegcode/pegcompiler.flow -- file=./nemo.lingo testfile=program.nemo result=1
